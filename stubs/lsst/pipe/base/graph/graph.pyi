import io
import networkx as nx
from ..pipeline import TaskDef
from ._implDetails import DatasetTypeName
from .quantumNode import NodeId, QuantumNode
from lsst.daf.butler import Quantum
from typing import Any, FrozenSet, Generator, Iterable, List, Mapping, Optional, Set, Tuple, Union

class IncompatibleGraphError(Exception): ...

class QuantumGraph:
    def __init__(self, quanta: Mapping[TaskDef, Set[Quantum]]) -> None: ...
    @property
    def taskGraph(self) -> nx.DiGraph: ...
    @property
    def graph(self) -> nx.DiGraph: ...
    @property
    def inputQuanta(self) -> Iterable[QuantumNode]: ...
    @property
    def outputQuanta(self) -> Iterable[QuantumNode]: ...
    @property
    def allDatasetTypes(self) -> Tuple[DatasetTypeName, ...]: ...
    @property
    def isConnected(self) -> bool: ...
    def getQuantumNodeByNodeId(self, nodeId: NodeId) -> QuantumNode: ...
    def getQuantaForTask(self, taskDef: TaskDef) -> FrozenSet[Quantum]: ...
    def findTasksWithInput(self, datasetTypeName: DatasetTypeName) -> Iterable[TaskDef]: ...
    def findTaskWithOutput(self, datasetTypeName: DatasetTypeName) -> Optional[TaskDef]: ...
    def tasksWithDSType(self, datasetTypeName: DatasetTypeName) -> Iterable[TaskDef]: ...
    def findTaskDefByName(self, taskName: str) -> List[TaskDef]: ...
    def findTaskDefByLabel(self, label: str) -> Optional[TaskDef]: ...
    def findQuantaWithDSType(self, datasetTypeName: DatasetTypeName) -> Set[Quantum]: ...
    def checkQuantumInGraph(self, quantum: Quantum) -> bool: ...
    def writeDotGraph(self, output: Union[str, io.BufferedIOBase]) -> Any: ...
    def subset(self, nodes: Union[QuantumNode, Iterable[QuantumNode]]) -> _T: ...
    def subsetToConnected(self) -> Tuple[_T, ...]: ...
    def determineInputsToQuantumNode(self, node: QuantumNode) -> Set[QuantumNode]: ...
    def determineOutputsOfQuantumNode(self, node: QuantumNode) -> Set[QuantumNode]: ...
    def determineConnectionsOfQuantumNode(self, node: QuantumNode) -> _T: ...
    def determineAncestorsOfQuantumNode(self, node: QuantumNode) -> _T: ...
    def findCycle(self) -> List[Tuple[QuantumNode, QuantumNode]]: ...
    def saveUri(self, uri: Any) -> None: ...
    @classmethod
    def loadUri(cls, uri: Any, universe: Any): ...
    def save(self, file: Any) -> None: ...
    @classmethod
    def load(cls, file: Any, universe: Any): ...
    def iterTaskGraph(self) -> Generator[TaskDef, None, None]: ...
    def __iter__(self) -> Generator[QuantumNode, None, None]: ...
    def __len__(self) -> int: ...
    def __contains__(self, node: QuantumNode) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
