import lsst.utils as pipeBase
from .coaddBase import CoaddBaseTask
from typing import Any, Optional

class AssembleCoaddConnections(pipeBase.PipelineTaskConnections):
    inputWarps: Any = ...
    skyMap: Any = ...
    brightObjectMask: Any = ...
    coaddExposure: Any = ...
    nImage: Any = ...
    def __init__(self, *, config: Optional[Any] = ...) -> None: ...

class AssembleCoaddConfig(CoaddBaseTask.ConfigClass, pipeBase.PipelineTaskConfig):
    warpType: Any = ...
    subregionSize: Any = ...
    statistic: Any = ...
    doSigmaClip: Any = ...
    sigmaClip: Any = ...
    clipIter: Any = ...
    calcErrorFromInputVariance: Any = ...
    scaleZeroPoint: Any = ...
    doInterp: Any = ...
    interpImage: Any = ...
    doWrite: Any = ...
    doNImage: Any = ...
    doUsePsfMatchedPolygons: Any = ...
    maskPropagationThresholds: Any = ...
    removeMaskPlanes: Any = ...
    doMaskBrightObjects: Any = ...
    brightObjectMaskName: Any = ...
    coaddPsf: Any = ...
    doAttachTransmissionCurve: Any = ...
    hasFakes: Any = ...
    badMaskPlanes: Any = ...
    def setDefaults(self) -> None: ...
    def validate(self) -> None: ...

class AssembleCoaddTask(CoaddBaseTask, pipeBase.PipelineTask):
    ConfigClass: Any = ...
    brightObjectBitmask: Any = ...
    warpType: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def runQuantum(self, butlerQC: Any, inputRefs: Any, outputRefs: Any): ...
    def runDataRef(self, dataRef: Any, selectDataList: Optional[Any] = ..., warpRefList: Optional[Any] = ...): ...
    def processResults(self, coaddExposure: Any, brightObjectMasks: Optional[Any] = ..., dataId: Optional[Any] = ...) -> None: ...
    def makeSupplementaryData(self, dataRef: Any, selectDataList: Optional[Any] = ..., warpRefList: Optional[Any] = ...): ...
    def makeSupplementaryDataGen3(self, butlerQC: Any, inputRefs: Any, outputRefs: Any): ...
    def getTempExpRefList(self, patchRef: Any, calExpRefList: Any): ...
    def prepareInputs(self, refList: Any): ...
    def prepareStats(self, mask: Optional[Any] = ...): ...
    def run(self, skyInfo: Any, tempExpRefList: Any, imageScalerList: Any, weightList: Any, altMaskList: Optional[Any] = ..., mask: Optional[Any] = ..., supplementaryData: Optional[Any] = ...): ...
    def assembleMetadata(self, coaddExposure: Any, tempExpRefList: Any, weightList: Any) -> None: ...
    def assembleSubregion(self, coaddExposure: Any, bbox: Any, tempExpRefList: Any, imageScalerList: Any, weightList: Any, altMaskList: Any, statsFlags: Any, statsCtrl: Any, nImage: Optional[Any] = ...) -> None: ...
    def removeMaskPlanes(self, maskedImage: Any) -> None: ...
    @staticmethod
    def setRejectedMaskMapping(statsCtrl: Any): ...
    def applyAltMaskPlanes(self, mask: Any, altMaskSpans: Any): ...
    def shrinkValidPolygons(self, coaddInputs: Any) -> None: ...
    def readBrightObjectMasks(self, dataRef: Any): ...
    def setBrightObjectMasks(self, exposure: Any, brightObjectMasks: Any, dataId: Optional[Any] = ...) -> None: ...
    def setInexactPsf(self, mask: Any) -> None: ...

class AssembleCoaddDataIdContainer(pipeBase.DataIdContainer):
    def makeDataRefList(self, namespace: Any) -> None: ...

class SafeClipAssembleCoaddConfig(AssembleCoaddConfig):
    assembleMeanCoadd: Any = ...
    assembleMeanClipCoadd: Any = ...
    clipDetection: Any = ...
    minClipFootOverlap: Any = ...
    minClipFootOverlapSingle: Any = ...
    minClipFootOverlapDouble: Any = ...
    maxClipFootOverlapDouble: Any = ...
    minBigOverlap: Any = ...
    sigmaClip: float = ...
    clipIter: int = ...
    statistic: str = ...
    def setDefaults(self) -> None: ...
    doSigmaClip: bool = ...
    def validate(self) -> None: ...

class SafeClipAssembleCoaddTask(AssembleCoaddTask):
    ConfigClass: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def run(self, skyInfo: Any, tempExpRefList: Any, imageScalerList: Any, weightList: Any, *args: Any, **kwargs: Any): ...
    def buildDifferenceImage(self, skyInfo: Any, tempExpRefList: Any, imageScalerList: Any, weightList: Any): ...
    def detectClip(self, exp: Any, tempExpRefList: Any): ...
    def detectClipBig(self, clipList: Any, clipFootprints: Any, clipIndices: Any, detectionFootprints: Any, maskClipValue: Any, maskDetValue: Any, coaddBBox: Any): ...

class CompareWarpAssembleCoaddConnections(AssembleCoaddConnections):
    psfMatchedWarps: Any = ...
    templateCoadd: Any = ...
    def __init__(self, *, config: Optional[Any] = ...) -> None: ...

class CompareWarpAssembleCoaddConfig(AssembleCoaddConfig):
    assembleStaticSkyModel: Any = ...
    detect: Any = ...
    detectTemplate: Any = ...
    maskStreaks: Any = ...
    streakMaskName: Any = ...
    maxNumEpochs: Any = ...
    maxFractionEpochsLow: Any = ...
    maxFractionEpochsHigh: Any = ...
    spatialThreshold: Any = ...
    doScaleWarpVariance: Any = ...
    scaleWarpVariance: Any = ...
    doPreserveContainedBySource: Any = ...
    doPrefilterArtifacts: Any = ...
    prefilterArtifactsMaskPlanes: Any = ...
    prefilterArtifactsRatio: Any = ...
    doFilterMorphological: Any = ...
    statistic: str = ...
    doUsePsfMatchedPolygons: bool = ...
    def setDefaults(self) -> None: ...
    def validate(self) -> None: ...

class CompareWarpAssembleCoaddTask(AssembleCoaddTask):
    ConfigClass: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def makeSupplementaryDataGen3(self, butlerQC: Any, inputRefs: Any, outputRefs: Any): ...
    def makeSupplementaryData(self, dataRef: Any, selectDataList: Optional[Any] = ..., warpRefList: Optional[Any] = ...): ...
    def run(self, skyInfo: Any, tempExpRefList: Any, imageScalerList: Any, weightList: Any, supplementaryData: Any, *args: Any, **kwargs: Any): ...
    def applyAltEdgeMask(self, mask: Any, altMaskList: Any) -> None: ...
    def findArtifacts(self, templateCoadd: Any, tempExpRefList: Any, imageScalerList: Any): ...
    def prefilterArtifacts(self, spanSetList: Any, exp: Any): ...
    def filterArtifacts(self, spanSetList: Any, epochCountImage: Any, nImage: Any, footprintsToExclude: Optional[Any] = ...): ...
