import argparse
from lsst.daf.butler import Butler, CollectionSearch, Registry
from typing import Any, Optional, Tuple

class _OutputChainedCollectionInfo:
    name: Any = ...
    chain: Any = ...
    exists: bool = ...
    def __init__(self, registry: Registry, name: str) -> None: ...

class _OutputRunCollectionInfo:
    name: Any = ...
    exists: bool = ...
    def __init__(self, registry: Registry, name: str) -> None: ...

class _ButlerFactory:
    output: Any = ...
    outputRun: Any = ...
    inputs: Any = ...
    def __init__(self, registry: Registry, args: argparse.Namespace, writeable: bool) -> None: ...
    def check(self, args: argparse.Namespace) -> Any: ...
    @classmethod
    def makeReadButler(cls: Any, args: argparse.Namespace) -> Butler: ...
    @classmethod
    def makeRegistryAndCollections(cls: Any, args: argparse.Namespace) -> Tuple[Registry, CollectionSearch, Optional[str]]: ...
    @classmethod
    def makeWriteButler(cls: Any, args: argparse.Namespace) -> Butler: ...

class _FilteredStream:
    def __init__(self, pattern: Any) -> None: ...
    def write(self, showStr: Any) -> None: ...

class CmdLineFwk:
    MP_TIMEOUT: int = ...
    def __init__(self) -> None: ...
    def makePipeline(self, args: Any): ...
    def makeGraph(self, pipeline: Any, args: Any): ...
    def runPipeline(self, graph: Any, taskFactory: Any, args: Any, butler: Optional[Any] = ...) -> None: ...
    def showInfo(self, args: Any, pipeline: Any, graph: Optional[Any] = ...) -> None: ...
