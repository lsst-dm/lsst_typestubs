from ..registry.interfaces import DatastoreRegistryBridgeManager
from ._butlerUri import ButlerURI
from .config import Config, ConfigSubset
from .configSupport import LookupKey
from .constraints import Constraints
from .datasets import DatasetRef, DatasetType
from .exceptions import ValidationError
from .fileDataset import FileDataset
from .storageClass import StorageClass, StorageClassFactory
from abc import ABCMeta, abstractmethod
from typing import Any, Callable, ClassVar, Dict, Iterable, Iterator, Mapping, Optional, Set, Tuple, Type, Union

class DatastoreConfig(ConfigSubset):
    component: str = ...
    requiredKeys: Any = ...
    defaultConfigFile: str = ...

class DatastoreValidationError(ValidationError): ...

class Event:
    name: str
    undoFunc: Callable
    args: tuple
    kwargs: dict
    def __init__(self, name: Any, undoFunc: Any, args: Any, kwargs: Any) -> None: ...

class IngestPrepData:
    refs: Any = ...
    def __init__(self, refs: Iterable[DatasetRef]) -> None: ...

class DatastoreTransaction:
    Event: ClassVar[Type] = ...
    parent: Optional[DatastoreTransaction]
    def __init__(self, parent: Optional[DatastoreTransaction]=...) -> None: ...
    def registerUndo(self, name: str, undoFunc: Callable, *args: Any, **kwargs: Any) -> None: ...
    def undoWith(self, name: str, undoFunc: Callable, *args: Any, **kwargs: Any) -> Iterator[None]: ...
    def rollback(self) -> None: ...
    def commit(self) -> None: ...

class Datastore(metaclass=ABCMeta):
    defaultConfigFile: ClassVar[Optional[str]] = ...
    containerKey: ClassVar[Optional[str]] = ...
    isEphemeral: bool = ...
    config: DatastoreConfig
    name: str
    storageClassFactory: StorageClassFactory
    constraints: Constraints
    IngestPrepData: ClassVar[Any] = ...
    @classmethod
    @abstractmethod
    def setConfigRoot(cls: Any, root: str, config: Config, full: Config, overwrite: bool=...) -> None: ...
    @staticmethod
    def fromConfig(config: Config, bridgeManager: DatastoreRegistryBridgeManager, butlerRoot: Optional[Union[str, ButlerURI]]=...) -> Datastore: ...
    def __init__(self, config: Union[Config, str], bridgeManager: DatastoreRegistryBridgeManager, butlerRoot: str=...) -> None: ...
    @property
    def names(self) -> Tuple[str, ...]: ...
    def transaction(self) -> Iterator[DatastoreTransaction]: ...
    @abstractmethod
    def exists(self, datasetRef: DatasetRef) -> bool: ...
    @abstractmethod
    def get(self, datasetRef: DatasetRef, parameters: Mapping[str, Any]=...) -> Any: ...
    @abstractmethod
    def put(self, inMemoryDataset: Any, datasetRef: DatasetRef) -> None: ...
    def ingest(self, *datasets: FileDataset, transfer: Optional[str]=...) -> None: ...
    @abstractmethod
    def getURIs(self, datasetRef: DatasetRef, predict: bool=...) -> Tuple[Optional[ButlerURI], Dict[str, ButlerURI]]: ...
    @abstractmethod
    def getURI(self, datasetRef: DatasetRef, predict: bool=...) -> ButlerURI: ...
    @abstractmethod
    def remove(self, datasetRef: DatasetRef) -> None: ...
    @abstractmethod
    def trash(self, datasetRef: DatasetRef, ignore_errors: bool=...) -> None: ...
    @abstractmethod
    def emptyTrash(self, ignore_errors: bool=...) -> None: ...
    @abstractmethod
    def transfer(self, inputDatastore: Datastore, datasetRef: DatasetRef) -> None: ...
    def export(self, refs: Iterable[DatasetRef], *, directory: Optional[str]=..., transfer: Optional[str]=...) -> Iterable[FileDataset]: ...
    @abstractmethod
    def validateConfiguration(self, entities: Iterable[Union[DatasetRef, DatasetType, StorageClass]], logFailures: bool=...) -> None: ...
    @abstractmethod
    def validateKey(self, lookupKey: LookupKey, entity: Union[DatasetRef, DatasetType, StorageClass]) -> None: ...
    @abstractmethod
    def getLookupKeys(self) -> Set[LookupKey]: ...
