from ..dimensions import Dimension, DimensionGraph, DimensionUniverse
from ..storageClass import StorageClass
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, Type, Union

class DatasetType:
    VALID_NAME_REGEX: Any = ...
    PlaceholderParentStorageClass: Any = ...
    @staticmethod
    def nameWithComponent(datasetTypeName: str, componentName: str) -> str: ...
    def __init__(self, name: str, dimensions: Union[DimensionGraph, Iterable[Dimension]], storageClass: Union[StorageClass, str], parentStorageClass: Optional[Union[StorageClass, str]]=..., *, universe: Optional[DimensionUniverse]=..., isCalibration: bool=...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: Any) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def dimensions(self) -> DimensionGraph: ...
    @property
    def storageClass(self) -> StorageClass: ...
    @property
    def parentStorageClass(self) -> Optional[StorageClass]: ...
    def isCalibration(self) -> bool: ...
    def finalizeParentStorageClass(self, newParent: StorageClass) -> None: ...
    @staticmethod
    def splitDatasetTypeName(datasetTypeName: str) -> Tuple[str, Optional[str]]: ...
    def nameAndComponent(self) -> Tuple[str, Optional[str]]: ...
    def component(self) -> Optional[str]: ...
    def componentTypeName(self, component: str) -> str: ...
    def makeComponentDatasetType(self, component: str) -> DatasetType: ...
    def makeAllComponentDatasetTypes(self) -> List[DatasetType]: ...
    def isComponent(self) -> bool: ...
    def isComposite(self) -> bool: ...
    def __reduce__(self) -> Tuple[Callable, Tuple[Type[DatasetType], Tuple[str, DimensionGraph, str, Optional[str]], Dict[str, bool]]]: ...
    def __deepcopy__(self, memo: Any) -> DatasetType: ...
