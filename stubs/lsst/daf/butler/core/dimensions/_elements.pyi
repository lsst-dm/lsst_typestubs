import abc
from .. import ddl
from .._topology import TopologicalRelationshipEndpoint
from ..named import NamedValueAbstractSet
from ._governor import GovernorDimension
from ._graph import DimensionGraph
from ._records import DimensionRecord
from ._universe import DimensionUniverse
from abc import abstractmethod
from typing import Any, Optional, Type

class DimensionElement(TopologicalRelationshipEndpoint, metaclass=abc.ABCMeta):
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: DimensionElement) -> bool: ...
    def __le__(self, other: DimensionElement) -> bool: ...
    def __gt__(self, other: DimensionElement) -> bool: ...
    def __ge__(self, other: DimensionElement) -> bool: ...
    def __reduce__(self) -> tuple: ...
    def __deepcopy__(self, memo: dict) -> DimensionElement: ...
    def hasTable(self) -> bool: ...
    universe: DimensionUniverse
    @property
    def governor(self) -> Optional[GovernorDimension]: ...
    @property
    @abstractmethod
    def required(self) -> NamedValueAbstractSet[Dimension]: ...
    @property
    @abstractmethod
    def implied(self) -> NamedValueAbstractSet[Dimension]: ...
    @property
    def dimensions(self) -> NamedValueAbstractSet[Dimension]: ...
    @property
    def graph(self) -> DimensionGraph: ...
    @property
    def RecordClass(self) -> Type[DimensionRecord]: ...
    @property
    @abstractmethod
    def metadata(self) -> NamedValueAbstractSet[ddl.FieldSpec]: ...
    @property
    def viewOf(self) -> Optional[str]: ...
    @property
    def alwaysJoin(self) -> bool: ...

class Dimension(DimensionElement, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def uniqueKeys(self) -> NamedValueAbstractSet[ddl.FieldSpec]: ...
    @property
    def primaryKey(self) -> ddl.FieldSpec: ...
    @property
    def alternateKeys(self) -> NamedValueAbstractSet[ddl.FieldSpec]: ...

class DimensionCombination(DimensionElement, metaclass=abc.ABCMeta): ...
