from .config import Config
from .configSupport import LookupKey
from .datasets import DatasetRef, DatasetType
from .dimensions import DataCoordinate, DimensionUniverse
from .fileDescriptor import FileDescriptor
from .location import Location
from .storageClass import StorageClass
from abc import ABCMeta, abstractmethod
from collections.abc import Mapping
from typing import AbstractSet, Any, ClassVar, Dict, Optional, Set, Tuple, Type, Union

Entity = Union[DatasetType, DatasetRef, StorageClass, str]

class Formatter(metaclass=ABCMeta):
    unsupportedParameters: ClassVar[Optional[AbstractSet[str]]] = ...
    supportedWriteParameters: ClassVar[Optional[AbstractSet[str]]] = ...
    supportedExtensions: ClassVar[AbstractSet[str]] = ...
    def __init__(self, fileDescriptor: FileDescriptor, dataId: Optional[DataCoordinate]=..., writeParameters: Optional[Dict[str, Any]]=..., writeRecipes: Optional[Dict[str, Any]]=...) -> None: ...
    @property
    def fileDescriptor(self) -> FileDescriptor: ...
    @property
    def dataId(self) -> Optional[DataCoordinate]: ...
    @property
    def writeParameters(self) -> Mapping[str, Any]: ...
    @property
    def writeRecipes(self) -> Mapping[str, Any]: ...
    @classmethod
    def validateWriteRecipes(cls: Any, recipes: Optional[Mapping[str, Any]]) -> Optional[Mapping[str, Any]]: ...
    @classmethod
    def name(cls: Any) -> str: ...
    @abstractmethod
    def read(self, component: Optional[str]=...) -> Any: ...
    @abstractmethod
    def write(self, inMemoryDataset: Any) -> None: ...
    @classmethod
    def can_read_bytes(cls: Any) -> bool: ...
    def fromBytes(self, serializedDataset: bytes, component: Optional[str]=...) -> object: ...
    def toBytes(self, inMemoryDataset: Any) -> bytes: ...
    def makeUpdatedLocation(self, location: Location) -> Location: ...
    @classmethod
    def validateExtension(cls: Any, location: Location) -> None: ...
    def predictPath(self) -> str: ...
    def segregateParameters(self, parameters: Optional[Dict[str, Any]]=...) -> Tuple[Dict, Dict]: ...

class FormatterFactory:
    defaultKey: Any = ...
    writeRecipesKey: Any = ...
    def __init__(self) -> None: ...
    def __contains__(self, key: Union[LookupKey, str]) -> bool: ...
    def registerFormatters(self, config: Config, universe: DimensionUniverse) -> None: ...
    def getLookupKeys(self) -> Set[LookupKey]: ...
    def getFormatterClassWithMatch(self, entity: Entity) -> Tuple[LookupKey, Type[Formatter], Dict[str, Any]]: ...
    def getFormatterClass(self, entity: Entity) -> Type: ...
    def getFormatterWithMatch(self, entity: Entity, *args: Any, **kwargs: Any) -> Tuple[LookupKey, Formatter]: ...
    def getFormatter(self, entity: Entity, *args: Any, **kwargs: Any) -> Formatter: ...
    def registerFormatter(self, type_: Union[LookupKey, str, StorageClass, DatasetType], formatter: str, *, overwrite: bool=..., **kwargs: Any) -> None: ...
FormatterParameter = Union[str, Type[Formatter], Formatter]
