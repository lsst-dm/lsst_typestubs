import psycopg2
import sqlalchemy.dialects.postgresql
from ...core import Timespan, TimespanDatabaseRepresentation, ddl
from ..interfaces import Database
from typing import Any, Dict, Iterable, Iterator, Mapping, Optional, Tuple, Type, Union

class PostgresqlDatabase(Database):
    namespace: Any = ...
    dbname: Any = ...
    def __init__(self, connection: sqlalchemy.engine.Connection, origin: int, *, namespace: Optional[str]=..., writeable: bool=...) -> None: ...
    @classmethod
    def connect(cls: Any, uri: str, *, writeable: bool=...) -> sqlalchemy.engine.Connection: ...
    @classmethod
    def fromConnection(cls: Any, connection: sqlalchemy.engine.Connection, origin: int, *, namespace: Optional[str]=..., writeable: bool=...) -> Database: ...
    def transaction(self, *, interrupting: bool=..., savepoint: bool=..., lock: Iterable[sqlalchemy.schema.Table]=...) -> Iterator[None]: ...
    def isWriteable(self) -> bool: ...
    def shrinkDatabaseEntityName(self, original: str) -> str: ...
    def expandDatabaseEntityName(self, shrunk: str) -> str: ...
    @classmethod
    def getTimespanRepresentation(cls: Any) -> Type[TimespanDatabaseRepresentation]: ...
    def replace(self, table: sqlalchemy.schema.Table, *rows: dict) -> None: ...
    def ensure(self, table: sqlalchemy.schema.Table, *rows: dict) -> int: ...

class _RangeTimespanType(sqlalchemy.TypeDecorator):
    impl: Any = ...
    def process_bind_param(self, value: Optional[Timespan], dialect: sqlalchemy.engine.Dialect) -> Optional[psycopg2.extras.NumericRange]: ...
    def process_result_value(self, value: Optional[psycopg2.extras.NumericRange], dialect: sqlalchemy.engine.Dialect) -> Optional[Timespan]: ...
    class comparator_factory(sqlalchemy.types.Concatenable.Comparator):
        def __ne__(self, other: Any) -> Any: ...
        def contains(self, other: Any, **kw: Any) -> Any: ...
        def contained_by(self, other: Any) -> Any: ...
        def overlaps(self, other: Any) -> Any: ...

class _RangeTimespanRepresentation(TimespanDatabaseRepresentation):
    column: Any = ...
    def __init__(self, column: sqlalchemy.sql.ColumnElement) -> None: ...
    @classmethod
    def makeFieldSpecs(cls: Any, nullable: bool, **kwargs: Any) -> Tuple[ddl.FieldSpec, ...]: ...
    @classmethod
    def getFieldNames(cls: Any) -> Tuple[str, ...]: ...
    @classmethod
    def update(cls: Any, timespan: Optional[Timespan], *, result: Optional[Dict[str, Any]]=...) -> Dict[str, Any]: ...
    @classmethod
    def extract(cls: Any, mapping: Mapping[str, Any]) -> Optional[Timespan]: ...
    @classmethod
    def hasExclusionConstraint(cls: Any) -> bool: ...
    @classmethod
    def fromSelectable(cls: Any, selectable: sqlalchemy.sql.FromClause) -> _RangeTimespanRepresentation: ...
    def isNull(self) -> sqlalchemy.sql.ColumnElement: ...
    def overlaps(self, other: Union[Timespan, _RangeTimespanRepresentation]) -> sqlalchemy.sql.ColumnElement: ...
