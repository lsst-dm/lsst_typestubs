import abc
import astropy.time
import enum
from .exprTree import Node
from .treeVisitor import TreeVisitor
from abc import ABC, abstractmethod
from typing import Any, Iterator, List, Optional, Sequence, Tuple

class LogicalBinaryOperator(enum.Enum):
    AND: bool = ...
    OR: bool = ...
    def apply(self, lhs: TransformationWrapper, rhs: TransformationWrapper) -> LogicalBinaryOperation: ...

class NormalForm(enum.Enum):
    CONJUNCTIVE: bool = ...
    DISJUNCTIVE: bool = ...
    @property
    def inner(self) -> LogicalBinaryOperator: ...
    @property
    def outer(self) -> LogicalBinaryOperator: ...
    def allows(self, inner: LogicalBinaryOperator, outer: LogicalBinaryOperator) -> bool: ...

class NormalFormVisitor(metaclass=abc.ABCMeta):
    @abstractmethod
    def visitBranch(self, node: Node) -> _T: ...
    @abstractmethod
    def visitInner(self, branches: Sequence[_T], form: NormalForm) -> _U: ...
    @abstractmethod
    def visitOuter(self, branches: Sequence[_U], form: NormalForm) -> _V: ...

class NormalFormExpression:
    def __init__(self, nodes: Sequence[Sequence[Node]], form: NormalForm) -> None: ...
    @staticmethod
    def fromTree(root: Node, form: NormalForm) -> NormalFormExpression: ...
    @property
    def form(self) -> NormalForm: ...
    def visit(self, visitor: NormalFormVisitor[_T, _U, _V]) -> _V: ...
    def toTree(self) -> Node: ...

class PrecedenceTier(enum.Enum):
    TOKEN: int = ...
    UNARY: int = ...
    VALUE_BINARY_OP: int = ...
    COMPARISON: int = ...
    AND: int = ...
    OR: int = ...
    @classmethod
    def needsParens(cls: Any, outer: PrecedenceTier, inner: PrecedenceTier) -> bool: ...

class TransformationWrapper(ABC, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def precedence(self) -> PrecedenceTier: ...
    @abstractmethod
    def not_(self) -> TransformationWrapper: ...
    def satisfies(self, form: NormalForm) -> bool: ...
    def normalize(self, form: NormalForm) -> TransformationWrapper: ...
    def flatten(self, operator: LogicalBinaryOperator) -> Iterator[TransformationWrapper]: ...
    @abstractmethod
    def unwrap(self) -> Node: ...

class Opaque(TransformationWrapper):
    def __init__(self, node: Node, precedence: PrecedenceTier) -> None: ...
    @property
    def precedence(self) -> PrecedenceTier: ...
    def not_(self) -> TransformationWrapper: ...
    def unwrap(self) -> Node: ...

class LogicalNot(TransformationWrapper):
    def __init__(self, operand: Opaque) -> None: ...
    @property
    def precedence(self) -> PrecedenceTier: ...
    def not_(self) -> TransformationWrapper: ...
    def unwrap(self) -> Node: ...

class LogicalBinaryOperation(TransformationWrapper):
    def __init__(self, lhs: TransformationWrapper, operator: LogicalBinaryOperator, rhs: TransformationWrapper) -> None: ...
    @property
    def precedence(self) -> PrecedenceTier: ...
    def not_(self) -> TransformationWrapper: ...
    def satisfies(self, form: NormalForm) -> bool: ...
    def normalize(self, form: NormalForm) -> TransformationWrapper: ...
    def flatten(self, operator: LogicalBinaryOperator) -> Iterator[TransformationWrapper]: ...
    def unwrap(self) -> Node: ...

class TransformationVisitor(TreeVisitor[TransformationWrapper]):
    def visitNumericLiteral(self, value: str, node: Node) -> TransformationWrapper: ...
    def visitStringLiteral(self, value: str, node: Node) -> TransformationWrapper: ...
    def visitTimeLiteral(self, value: astropy.time.Time, node: Node) -> TransformationWrapper: ...
    def visitRangeLiteral(self, start: int, stop: int, stride: Optional[int], node: Node) -> TransformationWrapper: ...
    def visitIdentifier(self, name: str, node: Node) -> TransformationWrapper: ...
    def visitUnaryOp(self, operator: str, operand: TransformationWrapper, node: Node) -> TransformationWrapper: ...
    def visitBinaryOp(self, operator: str, lhs: TransformationWrapper, rhs: TransformationWrapper, node: Node) -> TransformationWrapper: ...
    def visitIsIn(self, lhs: TransformationWrapper, values: List[TransformationWrapper], not_in: bool, node: Node) -> TransformationWrapper: ...
    def visitParens(self, expression: TransformationWrapper, node: Node) -> TransformationWrapper: ...
    def visitTupleNode(self, items: Tuple[TransformationWrapper, ...], node: Node) -> TransformationWrapper: ...
    def visitPointNode(self, ra: TransformationWrapper, dec: TransformationWrapper, node: Node) -> TransformationWrapper: ...

class TreeReconstructionVisitor(NormalFormVisitor[Node, Node, Node]):
    def visitBranch(self, node: Node) -> Node: ...
    def visitInner(self, branches: Sequence[Node], form: NormalForm) -> Node: ...
    def visitOuter(self, branches: Sequence[Node], form: NormalForm) -> Node: ...
