from . import queries
from .._butlerConfig import ButlerConfig
from ..core import ButlerURI, Config, DataCoordinate, DataId, DatasetAssociation, DatasetRef, DatasetType, Dimension, DimensionConfig, DimensionElement, DimensionGraph, DimensionRecord, DimensionUniverse, NameLookupMapping, Timespan, ddl
from ._collectionType import CollectionType
from ._config import RegistryConfig
from .interfaces import ButlerAttributeManager, CollectionManager, Database, DatasetRecordStorageManager, DatastoreRegistryBridgeManager, DimensionRecordStorageManager, OpaqueTableStorageManager
from .wildcards import CollectionSearch
from typing import Any, Iterable, Iterator, List, Mapping, Optional, Type, Union

class Registry:
    defaultConfigFile: Optional[str] = ...
    @classmethod
    def createFromConfig(cls: Any, config: Optional[Union[RegistryConfig, str]]=..., dimensionConfig: Optional[Union[DimensionConfig, str]]=..., butlerRoot: Optional[str]=...) -> Registry: ...
    @classmethod
    def fromConfig(cls: Any, config: Union[ButlerConfig, RegistryConfig, Config, str], butlerRoot: Optional[Union[str, ButlerURI]]=..., writeable: bool=...) -> Registry: ...
    storageClasses: Any = ...
    def __init__(self, database: Database, attributes: Type[ButlerAttributeManager], opaque: Type[OpaqueTableStorageManager], dimensions: Type[DimensionRecordStorageManager], collections: Type[CollectionManager], datasets: Type[DatasetRecordStorageManager], datastoreBridges: Type[DatastoreRegistryBridgeManager], *, dimensionConfig: Optional[DimensionConfig]=..., writeable: bool=..., create: bool=...): ...
    def isWriteable(self) -> bool: ...
    @property
    def dimensions(self) -> DimensionUniverse: ...
    def transaction(self, *, savepoint: bool=...) -> Iterator[None]: ...
    def registerOpaqueTable(self, tableName: str, spec: ddl.TableSpec) -> None: ...
    def insertOpaqueData(self, tableName: str, *data: dict) -> None: ...
    def fetchOpaqueData(self, tableName: str, **where: Any) -> Iterator[dict]: ...
    def deleteOpaqueData(self, tableName: str, **where: Any) -> None: ...
    def registerCollection(self, name: str, type: CollectionType=..., doc: Optional[str]=...) -> None: ...
    def getCollectionType(self, name: str) -> CollectionType: ...
    def registerRun(self, name: str, doc: Optional[str]=...) -> None: ...
    def removeCollection(self, name: str) -> None: ...
    def getCollectionChain(self, parent: str) -> CollectionSearch: ...
    def setCollectionChain(self, parent: str, children: Any) -> None: ...
    def getCollectionDocumentation(self, collection: str) -> Optional[str]: ...
    def setCollectionDocumentation(self, collection: str, doc: Optional[str]) -> None: ...
    def registerDatasetType(self, datasetType: DatasetType) -> bool: ...
    def removeDatasetType(self, name: str) -> None: ...
    def getDatasetType(self, name: str) -> DatasetType: ...
    def findDataset(self, datasetType: Union[DatasetType, str], dataId: Optional[DataId]=..., collections: Any, *, timespan: Optional[Timespan]=..., **kwargs: Any) -> Optional[DatasetRef]: ...
    def insertDatasets(self, datasetType: Union[DatasetType, str], dataIds: Iterable[DataId], run: str) -> List[DatasetRef]: ...
    def getDataset(self, id: int) -> Optional[DatasetRef]: ...
    def removeDatasets(self, refs: Iterable[DatasetRef]) -> None: ...
    def associate(self, collection: str, refs: Iterable[DatasetRef]) -> None: ...
    def disassociate(self, collection: str, refs: Iterable[DatasetRef]) -> None: ...
    def certify(self, collection: str, refs: Iterable[DatasetRef], timespan: Timespan) -> None: ...
    def decertify(self, collection: str, datasetType: Union[str, DatasetType], timespan: Timespan, *, dataIds: Optional[Iterable[DataId]]=...) -> None: ...
    def getDatastoreBridgeManager(self) -> DatastoreRegistryBridgeManager: ...
    def getDatasetLocations(self, ref: DatasetRef) -> Iterable[str]: ...
    def expandDataId(self, dataId: Optional[DataId]=..., *, graph: Optional[DimensionGraph]=..., records: Optional[NameLookupMapping[DimensionElement, Optional[DimensionRecord]]]=..., **kwargs: Any) -> DataCoordinate: ...
    def insertDimensionData(self, element: Union[DimensionElement, str], *data: Union[Mapping[str, Any], DimensionRecord], conform: bool=...) -> None: ...
    def syncDimensionData(self, element: Union[DimensionElement, str], row: Union[Mapping[str, Any], DimensionRecord], conform: bool=...) -> bool: ...
    def queryDatasetTypes(self, expression: Any=..., *, components: Optional[bool]=...) -> Iterator[DatasetType]: ...
    def queryCollections(self, expression: Any=..., datasetType: Optional[DatasetType]=..., collectionTypes: Iterable[CollectionType]=..., flattenChains: bool=..., includeChains: Optional[bool]=...) -> Iterator[str]: ...
    def makeQueryBuilder(self, summary: queries.QuerySummary) -> queries.QueryBuilder: ...
    def queryDatasets(self, datasetType: Any, collections: Any, *, dimensions: Optional[Iterable[Union[Dimension, str]]]=..., dataId: Optional[DataId]=..., where: Optional[str]=..., findFirst: bool=..., components: Optional[bool]=..., check: bool=..., **kwargs: Any) -> queries.DatasetQueryResults: ...
    def queryDataIds(self, dimensions: Union[Iterable[Union[Dimension, str]], Dimension, str], *, dataId: Optional[DataId]=..., datasets: Any=..., collections: Any=..., where: Optional[str]=..., components: Optional[bool]=..., check: bool=..., **kwargs: Any) -> queries.DataCoordinateQueryResults: ...
    def queryDimensionRecords(self, element: Union[DimensionElement, str], *, dataId: Optional[DataId]=..., datasets: Any=..., collections: Any=..., where: Optional[str]=..., components: Optional[bool]=..., check: bool=..., **kwargs: Any) -> Iterator[DimensionRecord]: ...
    def queryDatasetAssociations(self, datasetType: Union[str, DatasetType], collections: Any=..., *, collectionTypes: Iterable[CollectionType]=..., flattenChains: bool=...) -> Iterator[DatasetAssociation]: ...
