import re
import sqlalchemy
from ..core import DataCoordinate, DatasetType, DimensionUniverse, GovernorDimension
from ..core.named import NamedKeyMapping
from ._collectionType import CollectionType
from .interfaces import CollectionManager, CollectionRecord
from enum import Enum
from typing import AbstractSet, Any, Callable, ClassVar, FrozenSet, Iterable, Iterator, List, Optional, Sequence, Set, Tuple, Union

class EllipsisType(Enum):
    Ellipsis: str = ...

class CategorizedWildcard:
    @classmethod
    def fromExpression(cls: Any, expression: Any, *, allowAny: bool=..., allowPatterns: bool=..., coerceUnrecognized: Optional[Callable[[Any], Union[Tuple[str, Any], str]]]=..., coerceItemValue: Optional[Callable[[Any], Any]]=..., defaultItemValue: Optional[Any]=...) -> Union[CategorizedWildcard, EllipsisType]: ...
    def makeWhereExpression(self, column: sqlalchemy.sql.ColumnElement) -> Optional[sqlalchemy.sql.ColumnElement]: ...
    strings: List[str]
    patterns: List[re.Pattern]
    items: List[Tuple[str, Any]]
    def __init__(self, strings: Any, patterns: Any, items: Any) -> None: ...

class DatasetTypeRestriction:
    names: Any = ...
    def __init__(self, names: Union[FrozenSet[str], EllipsisType]) -> None: ...
    @classmethod
    def fromExpression(cls: Any, expression: Any) -> DatasetTypeRestriction: ...
    def __contains__(self, datasetType: DatasetType) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    @staticmethod
    def union(*args: DatasetTypeRestriction) -> DatasetTypeRestriction: ...
    any: ClassVar[DatasetTypeRestriction]

class GovernorDimensionRestriction:
    universe: Any = ...
    def __init__(self, universe: DimensionUniverse, **kwargs: Union[str, Iterable[str], EllipsisType]) -> None: ...
    @staticmethod
    def union(universe: DimensionUniverse, *args: GovernorDimensionRestriction) -> GovernorDimensionRestriction: ...
    def __eq__(self, other: Any) -> bool: ...
    def isConsistentWith(self, dataId: DataCoordinate) -> bool: ...
    @property
    def mapping(self) -> NamedKeyMapping[GovernorDimension, AbstractSet[str]]: ...

class CollectionContentRestriction:
    datasetTypes: Any = ...
    dimensions: Any = ...
    def __init__(self, datasetTypes: DatasetTypeRestriction=..., dimensions: Optional[GovernorDimensionRestriction]=..., *, universe: Optional[DimensionUniverse]=...) -> None: ...
    @classmethod
    def fromExpression(cls: Any, expression: Any, universe: DimensionUniverse) -> CollectionContentRestriction: ...
    @staticmethod
    def union(universe: DimensionUniverse, *args: CollectionContentRestriction) -> CollectionContentRestriction: ...
    @classmethod
    def fromPairs(cls: Any, pairs: Iterable[Tuple[str, Optional[str]]], universe: DimensionUniverse) -> CollectionContentRestriction: ...
    def toPairs(self) -> Iterator[Tuple[str, Optional[str]]]: ...
    def __eq__(self, other: Any) -> bool: ...

class CollectionSearch(Sequence[str]):
    def __init__(self, collections: Tuple[str, ...]) -> None: ...
    @classmethod
    def fromExpression(cls: Any, expression: Any) -> CollectionSearch: ...
    def iter(self, manager: CollectionManager, *, datasetType: Optional[DatasetType]=..., collectionTypes: AbstractSet[CollectionType]=..., done: Optional[Set[str]]=..., flattenChains: bool=..., includeChains: Optional[bool]=...) -> Iterator[CollectionRecord]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: Any) -> str: ...
    def __eq__(self, other: Any) -> bool: ...

class CollectionQuery:
    def __init__(self, search: Union[CollectionSearch, EllipsisType]=..., patterns: Tuple[re.Pattern, ...]=...) -> None: ...
    @classmethod
    def fromExpression(cls: Any, expression: Any) -> CollectionQuery: ...
    def iter(self, manager: CollectionManager, *, collectionTypes: AbstractSet[CollectionType]=..., flattenChains: bool=..., includeChains: Optional[bool]=...) -> Iterator[CollectionRecord]: ...
    def __eq__(self, other: Any) -> bool: ...
