from ._deferredDatasetHandle import DeferredDatasetHandle
from .core import ButlerURI, Config, DataId, DatasetRef, DatasetType, FileDataset, ValidationError
from .registry import CollectionType
from .transfers import RepoExportContext
from typing import Any, ClassVar, Dict, Iterable, Iterator, List, Mapping, Optional, Set, TextIO, Tuple, Union

class ButlerValidationError(ValidationError): ...
class PruneCollectionsArgsError(TypeError): ...

class PurgeWithoutUnstorePruneCollectionsError(PruneCollectionsArgsError):
    def __init__(self) -> None: ...

class RunWithoutPurgePruneCollectionsError(PruneCollectionsArgsError):
    collectionType: Any = ...
    def __init__(self, collectionType: CollectionType) -> None: ...

class PurgeUnsupportedPruneCollectionsError(PruneCollectionsArgsError):
    collectionType: Any = ...
    def __init__(self, collectionType: CollectionType) -> None: ...

class Butler:
    tags: Any = ...
    registry: Any = ...
    datastore: Any = ...
    storageClasses: Any = ...
    collections: Any = ...
    run: Any = ...
    def __init__(self, config: Union[Config, str, None]=..., *, butler: Optional[Butler]=..., collections: Any=..., run: Optional[str]=..., tags: Iterable[str]=..., chains: Optional[Mapping[str, Any]]=..., searchPaths: Optional[List[str]]=..., writeable: Optional[bool]=...) -> None: ...
    GENERATION: ClassVar[int] = ...
    @staticmethod
    def makeRepo(root: str, config: Union[Config, str, None]=..., dimensionConfig: Union[Config, str, None]=..., standalone: bool=..., searchPaths: Optional[List[str]]=..., forceConfigRoot: bool=..., outfile: Optional[str]=..., overwrite: bool=...) -> Config: ...
    def __reduce__(self) -> tuple: ...
    def isWriteable(self) -> bool: ...
    def transaction(self) -> Iterator[None]: ...
    def put(self, obj: Any, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, run: Optional[str]=..., tags: Optional[Iterable[str]]=..., **kwds: Any) -> DatasetRef: ...
    def getDirect(self, ref: DatasetRef, *, parameters: Optional[Dict[str, Any]]=...) -> Any: ...
    def getDirectDeferred(self, ref: DatasetRef, *, parameters: Union[dict, None]=...) -> DeferredDatasetHandle: ...
    def getDeferred(self, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, parameters: Union[dict, None]=..., collections: Any=..., **kwds: Any) -> DeferredDatasetHandle: ...
    def get(self, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, parameters: Optional[Dict[str, Any]]=..., collections: Any=..., **kwds: Any) -> Any: ...
    def getURIs(self, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, predict: bool=..., collections: Any=..., run: Optional[str]=..., **kwds: Any) -> Tuple[Optional[ButlerURI], Dict[str, ButlerURI]]: ...
    def getURI(self, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, predict: bool=..., collections: Any=..., run: Optional[str]=..., **kwds: Any) -> ButlerURI: ...
    def datasetExists(self, datasetRefOrType: Union[DatasetRef, DatasetType, str], dataId: Optional[DataId]=..., *, collections: Any=..., **kwds: Any) -> bool: ...
    def pruneCollection(self, name: str, purge: bool=..., unstore: bool=...) -> None: ...
    def pruneDatasets(self, refs: Iterable[DatasetRef], *, disassociate: bool=..., unstore: bool=..., tags: Optional[Iterable[str]]=..., purge: bool=..., run: Optional[str]=...) -> None: ...
    def ingest(self, *datasets: FileDataset, transfer: Optional[str]=..., run: Optional[str]=..., tags: Optional[Iterable[str]]=...) -> None: ...
    def export(self, *, directory: Optional[str]=..., filename: Optional[str]=..., format: Optional[str]=..., transfer: Optional[str]=...) -> Iterator[RepoExportContext]: ...
    def import_(self, *, directory: Optional[str]=..., filename: Union[str, TextIO, None]=..., format: Optional[str]=..., transfer: Optional[str]=..., skip_dimensions: Optional[Set]=...) -> None: ...
    def validateConfiguration(self, logFailures: bool=..., datasetTypeNames: Optional[Iterable[str]]=..., ignore: Iterable[str]=...) -> None: ...
